# 多线程(重要)

## 多线程

多线程是什么？

- 多线程是指从硬件上实现多条执行流程的技术

多线程用在哪？有什么好处

- 购票系统
- 百度网盘的下载
- 消息通信，淘宝，京东...



## 多线程的创建

### 方式一：继承Thread类

1. 定义一个子类MyThread继承线程类java.lang.Thread，重写run()方法
2. 创建MyThread类对象
3. 调用线程对象的start()方法启动线程

```java
package com.demo1;

/**
 * 掌握多线程的创建方式一：继承Thread类
 */
public class Demo1 {
    public static void main(String[] args) {
        //1、new一个新线程对象，代表线程
        Thread t = new MyThread();
        //2、调用start方法执行线程中的run方法
        t.start();//实现了多线程

        //写一个主线程
        for (int i = 0; i < 5; i++) {
            System.out.println("主线程执行输出" + i);
        }

    }
}

/**
 * 定义一个线程类继承Thread类
 */
class MyThread extends Thread{
    /**
     * 重写run方法，里面是定义线程以后要干啥
     */
    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println("子线程执行输出" + i);
        }
    }
}

```



#### 优缺点：

- 优点：编码简单
- 缺点：线程类已经继承Thread，无法继承其他类，不利于扩展

#### 疑问：

为什么不是调用run方法启动多线程，而是调用start方法呢？

- 如果直接调用run方法会当成普通方法执行，此时相当于还是单线程执行

#### 注意点：

**不要**把**主线程**的任务放到**子线程**任务之前，否则主线程一直是先跑完的，相当于是一个单线程的效果了。



### 方式二：实现Runnable接口

1. 定义一个线程任务类MyRunnable实现Runnable接口，重写run()方法
2. 创建MyRunnable任务对象
3. 把MyRunnable任务对象交给Thread处理
4. 调用线程对象的start()方法启动线程



```java
package com.demo1;

public class Demo2 {
    public static void main(String[] args) {
        //创建一个任务对象
        Runnable target = new MyRunnable();
        //把任务对象交给Thread对象处理
        Thread t = new Thread(target);
        //启动线程
        t.start();

        //定义主线程（在main中）
        for (int i = 0; i < 10; i++) {
            System.out.println("主线程执行输出" + i);
        }


    }
}

/**
 * 定义一个线程任务类，实现Runnable接口
 */
class MyRunnable implements Runnable{

    /**
     * 实现run方法
     */
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println("子线程执行输出" + i);
        }
    }
}

```



#### 优缺点：

- 优点：线程任务只是实现接口，可以继续继承和实现接口，扩展性强
- 缺点：编程多一层对象包装，如果线程有执行结构，是不可以直接返回的



#### 实现Runnable接口（匿名内部类形式）

```java
package com.demo1;

public class Demo2 {
    public static void main(String[] args) {
        

        //匿名内部类形式
        Runnable target = new Runnable(){
            @Override
            public void run() {
                for (int i = 0; i < 10; i++) {
                    System.out.println("子线程1执行输出" + i);
                }
            }
        };
        Thread thread = new Thread(target);
        thread.start();
        //简化
        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 10; i++) {
                    System.out.println("子线程2执行输出" + i);
                }
            }
        }).start();
        //简化
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                System.out.println("子线程3执行输出" + i);
            }
        }).start();

        //定义主线程（在main中）
        for (int i = 0; i < 10; i++) {
            System.out.println("主线程执行输出" + i);
        }


    }
}



```



### 方式三：JDK5.0新增：实现Callable接口

- 前两种线程创建的方式都存在一个问题：
  - 他们重写的run方法不能返回结果
  - 不适合需要返回线程执行结果的业务场景
- 于是JDK5.0提供了Callable和FutureTask，可以解决这个问题



1. 得到任务对象
   - 定义类实现Callable接口，重写call方法，封装要做的事情
   - 用FutureTask把Callable对象封装成线程任务对象
2. 把线程任务对象交给Thread处理
3. 调用Thread的start方法启动线程，执行任务
4. 线程执行完毕后，通过FutureTask的get方法区获取任务执行的结果



```java
package com.demo1;

import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;

public class Demo3 {
    public static void main(String[] args) {
        //创建任务对象
        Callable<String> call = new MyCallable(100);
        //把Callable任务对象交给FutureTask对象
        //FutureTask对象的作用1：是Runnable的对象（实现了Runnable接口），可以交给Thread了
        //FutureTask对象的作用2：可以在线程执行完毕后通过调用其get方法得到线程执行完毕的结果
        FutureTask<String> task = new FutureTask<>(call);
        //交给线程处理
        Thread thread = new Thread(task);
        //启动线程
        thread.start();
        //获取结果（主线程）
        try {
            //如果task任务没有执行完，这里的代码会等待，直到线程跑完才取出结果
            String rs1 = task.get();
            System.out.println("第一个结果："+rs1);
        }  catch (Exception e) {
            e.printStackTrace();
        }

        Callable<String> call2 = new MyCallable(200);
        FutureTask<String> task2 = new FutureTask<>(call2);
        Thread thread2 = new Thread(task2);
        thread2.start();
        try {
            String rs2 = task2.get();
            System.out.println("第二个结果："+rs2);
        } catch (Exception e) {
            e.printStackTrace();
        }


    }
}

/**
 * 定义一个任务类，实现Callable接口，应该声明线程任务执行完毕后的结果数据类型
 */
class MyCallable implements Callable<String>{
    //计算1到n的和
    private int n;

    public MyCallable(int n) {
        this.n = n;
    }

    /**
     * 重写call方法
     * @return
     * @throws Exception
     */
    @Override
    public String call() throws Exception {
        int sum = 0;
        for (int i = 0; i <= n; i++) {
            sum += i;
        }
        return "子线程执行的结果为：" + sum;
    }
}
```



#### 优缺点：

- 优点：线程任务类只是实现接口，可以继续继承和实现接口，扩展性强
- 优点：可以在线程执行完毕后通过FutureTask的get方法获取执行结果，如果没有执行完毕（一定要调用Thread的start方法，才能执行！！）会等待执行完毕后，获取结果）
- 缺点：编码复杂一些



### 总结

| 方式             | 优点                                                         | 缺点                                                       |
| ---------------- | ------------------------------------------------------------ | ---------------------------------------------------------- |
| 继承Thread类     | 编码简单，可以直接使用Thread类中的start方法启动线程          | 扩展性较差，不能在继续继承其他的类，不能返回线程执行的结果 |
| 实现Runnable接口 | 扩展性强，实现该接口的同时还可以继承其他的类                 | 编程相对复杂，不能返回线程执行的结果                       |
| 实现Callable接口 | 扩展性强，实现该接口的同时还可以继承其他的类，可以得到线程执行的结果 | 编程相对复杂                                               |



## Thread的常用方法

- Thread常用方法：获取线程名称getName()、设置名称setName()、获取当前线程对象currentThread()



1. 当有很多线程执行的时候，我们怎么区分这些线程？

   可以使用Thread的常用方法：getName()、setName()、currentThread()等



```java
package com.api;

public class MyThread extends Thread{
    public MyThread() {
    }

    public MyThread(String name) {
        //为当前线程对象设置名字，送给父类的有参构造器初始化名称
        super(name);
    }

    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println(Thread.currentThread().getName()+"子线程输出");
        }
    }
}

```



```java
package com.api;

public class Demo1 {
    public static void main(String[] args) {
        Thread t1 = new MyThread("1号");
//        t1.setName("1号");
        t1.start();
//        System.out.println(t1.getName());

        Thread t2 = new MyThread("2号");
//        t2.setName("2号");
        t2.start();
//        System.out.println(t2.getName());


        /**
         * 哪个线程执行它，它就代表哪个多线程对象（当前线程对象）
         * 主线程的默认名称就叫main
         */
        Thread m = Thread.currentThread();
        System.out.println(m.getName());
        for (int i = 0; i < 5; i++) {
            System.out.println("main线程输出");
        }
    }
}

```



## Thread类的线程休眠方法



| 方法名称                            | 说明                                             |
| ----------------------------------- | ------------------------------------------------ |
| public static void sleep(long time) | 让当前线程休眠指定的时间后再继续执行，单位为毫秒 |



```java
package com.api;

public class Demo2 {
    public static void main(String[] args) throws Exception {
        for (int i = 0; i < 5; i++) {
            System.out.println("输出"+i);
            if (i == 2){
                System.out.println("睡3秒休息一下~~");
                //让当前线程进入休眠状态
                Thread.sleep(3000);
            }
        }
    }
}

```



### 总结

Thread常用方法、构造器

| 方法名称                                                     | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| String getName()                                             | 获取线程当前的名称，默认线程名称为Thread-索引                |
| void setName(String name)                                    | 设置线程名称                                                 |
| public static Thread currentThread()     例如：如果在main方法中写：Thread m = Thread.currentThread(); m就代表main方法的线程 | 返回对当前正在执行的线程对象的引用。<br/>返回值：当前正在执行的线程。 |
| public static void sleep(long time)                          | 让线程休眠指定的时间，单位毫秒                               |
| public void run()                                            | 线程任务方法                                                 |
| punlic void start()                                          | 线程启动方法                                                 |

| 构造器                                     | 说明                                       |
| ------------------------------------------ | ------------------------------------------ |
| public Thread(String name)                 | 可以设置当前线程指定的名称                 |
| public Thread(Runnable target)             | 把Runnable对象交给线程对象                 |
| public Thread(Runnable target,String name) | 把Runnable对象交给线程对象，并指定线程名称 |





## 线程安全

### 线程安全是什么、方式的原因

- 多个线程**同时**操作同一个**共享资源**的时候，可能会出现**业务（比如修改数据）**安全问题，称为线程安全问题



#### 取钱模型

- 需求：小明和小红是一对夫妻，他们有一个共同的账户，余额是10万元
- 如果小明和小红同时来取钱，而且2人都需要取钱10万元，可能出现什么问题？



#### 模拟线程安全问题：

```java
package com.thread_safe;

public class Account {
    private String cardId;
    private double money;

    public Account() {
    }

    public Account(String cardId, double money) {
        this.cardId = cardId;
        this.money = money;
    }
    /**
     * 小明 小红 取钱
     * @param money
     */
    public void drawMoney(double money) {
        //1、获取是谁来取钱
        String name = Thread.currentThread().getName();
        //2、判断账户余额
        if (this.money >= money){
            //2、取钱
            System.out.println(name + "取钱成功：" + money);
            //3、更新余额
            this.money -= money;
            System.out.println(name + "取钱后剩余：" + this.money);
        }else {
            //余额不足
            System.out.println(name + "余额不足");
        }
    }

    public String getCardId() {
        return cardId;
    }

    public void setCardId(String cardId) {
        this.cardId = cardId;
    }

    public double getMoney() {
        return money;
    }

    public void setMoney(double money) {
        this.money = money;
    }


}

```

```java
package com.thread_safe;

/**
 * 取钱的线程类
 */
public class DrawThread extends Thread{
    private Account account;
    public DrawThread(Account account,String name){
        super(name);
        this.account = account;
    }
    @Override
    public void run() {
        //取钱
        account.drawMoney(100000);

    }
}

```

```java
package com.thread_safe;

/**
 * 模拟取钱案例
 */
public class Demo1 {
    public static void main(String[] args) {
        //1、定义线程类，创建一个共享的账户对象
        Account account = new Account("001",100000);

        //2、创建两个线程对象，代表小明和小红同时进来了
        new DrawThread(account,"小明").start();
        new DrawThread(account,"小红").start();
    }
}

```

输出结果：

小红取钱成功：100000.0
小红取钱后剩余：0.0
小明取钱成功：100000.0
小明取钱后剩余：-100000.0



线程安全问题发生的原因是什么？

- 多个线程同时访问同一个共享资源且存在修改资源的时候，可能会出现线程安全问题



## 线程同步

- 为了解决线程安全问题

1. 取钱案例出现的问题原因

   多个线程同时执行，发现账户余额是足够的

2. 如何解决？

   - 让多个线程实现先后依次访问共享资源，这样就解决了安全问题（一起进入账户，然后依次访问，排队）



### 线程同步核心思想

- 加锁，把共享资源进行上锁，每次只能一个人进入访问，完毕以后进行解锁，然后其他线程才能进来



### 方式一：同步代码块

- 作用：把出现线程安全问题的核心代码给上锁
- 原理：每次只能一个线程进入，执行完毕后自动解锁，其他线程才可以进来执行



```java
synchronized ("lock") {
            //2、判断账户余额
            if (this.money >= money){
                //2、取钱
                System.out.println(name + "取钱成功：" + money);
                //3、更新余额
                this.money -= money;
                System.out.println(name + "取钱后剩余：" + this.money);
            }else {
                //余额不足
                System.out.println(name + "余额不足");
            }
        }
```



### 锁对象要求

- 理论上：锁对象只要对于当前同时执行的线程来说是同一个对象即可



#### 锁对象用任意唯一的对象好不好呢？

- 不好，因为会影响到其他无关线程的执行



#### 锁对象的规范要求

- 规范：**建议使用共享资源作为锁对象**
- 对于实例方法建议使用this作为锁对象
- 对于静态方法建议使用字节码（类名.class）对象作为锁对象

```java
synchronized (this) {
            //2、判断账户余额
            if (this.money >= money){
                //2、取钱
                System.out.println(name + "取钱成功：" + money);
                //3、更新余额
                this.money -= money;
                System.out.println(name + "取钱后剩余：" + this.money);
            }else {
                //余额不足
                System.out.println(name + "余额不足");
            }
        }
```

### 方式二：同步方法

- 作用：把出现线程安全问题的核心方法给上锁
- 原理：每次只能一个线程进入，执行完毕以后自动解锁，其他线程才可以进来执行



```java
/**
     * 小明 小红 取钱
     * @param money
     */
    public synchronized void drawMoney(double money) {
        //1、获取是谁来取钱
        String name = Thread.currentThread().getName();


            //2、判断账户余额
            if (this.money >= money){
                //2、取钱
                System.out.println(name + "取钱成功：" + money);
                //3、更新余额
                this.money -= money;
                System.out.println(name + "取钱后剩余：" + this.money);
            }else {
                //余额不足
                System.out.println(name + "余额不足");
            }
        }
```



格式：

```java
public synchronized void run(){//实例方法：同步方法默认用this作为锁的对象。但是代码要高度面向对象
        
        }
public synchronized static void run1(){//静态方法，同步方法默认用类名.class作为锁对象
        
        }
```





#### 同步方法底层原理

- 同步方法其实底层也是有隐式锁对象的，只是锁的范围是整个方法代码块
- 如果方法是实例方法：同步方法默认用this作为锁的对象。但是代码要高度面向对象
- 如果方法是静态方法：同步方法默认用类名.class作为锁对象



是同步代码块好还是同步方法好？

- 同步代码块锁的范围更小，同步方法锁的范围更大
- 同步方法可读性方便



### Lock锁

- 为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock，更加灵活、方便
- Lock锁实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作
- Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来构建Lock对象

| 方法名称               | 说明                   |
| ---------------------- | ---------------------- |
| Public ReentrantLock() | 获得Lock锁的实现类对象 |

Lock的API

| 方法          | 说明   |
| ------------- | ------ |
| void lock()   | 获得锁 |
| void unlock() | 释放锁 |

```java
private final Lock lock = new ReentrantLock();//final修饰后：锁对象是唯一不可替换的，非常专业
```

```java
			lock.lock();//上锁
        try {
           //上锁的内容
        } finally {
            lock.unlock();//解锁，写在finally中，防止出现bug然后被锁死！！！
        }
```



```java
package com.thread_lock;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Account {
    private String cardId;
    private double money;
    private final Lock lock = new ReentrantLock();//final修饰后：锁对象是唯一不可替换的，非常专业

    public Account() {
    }

    public Account(String cardId, double money) {
        this.cardId = cardId;
        this.money = money;
    }
    /**
     * 小明 小红 取钱
     * @param money
     */
    public void drawMoney(double money) {
        //1、获取是谁来取钱
        String name = Thread.currentThread().getName();


        lock.lock();//上锁
        try {
            //2、判断账户余额
            if (this.money >= money){
                //2、取钱
                System.out.println(name + "取钱成功：" + money);
                //3、更新余额
                this.money -= money;
                System.out.println(name + "取钱后剩余：" + this.money);
            }else {
                //余额不足
                System.out.println(name + "余额不足");
            }
        } finally {
            lock.unlock();//解锁，写在finally中，防止出现bug然后被锁死！！！
        }

    }
    public String getCardId() {
        return cardId;
    }

    public void setCardId(String cardId) {
        this.cardId = cardId;
    }

    public double getMoney() {
        return money;
    }

    public void setMoney(double money) {
        this.money = money;
    }
}

```





# 线程通信

什么是线程通信、如何实现？

- 所谓线程通信就是线程间互相发送数据

线程通信常见的形式

- 通过共享一个数据的方式实现
- 根据共享数据的情况决定自己改怎么做，以及通知其他线程怎么做





# 线程池[重点]

## 概述

- 线程池就是一个可以复用线程的技术

不使用线程池的问题

- 如果用户每发起一个请求，后台就创建一个新的线程来处理，下次新任务来了又要创建新线程，而创建新线程的开销是很大的，这样会严重影响系统的性能



## 线程池实现的API、参数说明

### 谁代表线程池？

- JDK5.0起提供了代表线程池的接口：ExecutorService

### 如何得到线程对象？

- 方式一：使用ExecutorService的实现类ThreadPoolExecutor自己创建一个线程对象【重要】
- 方式二：使用Executor（线程池工具类）调用方法返回不同特点的线程池对象



### ThreadPoolExecutor构造器的参数说明

```java
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)
```

参数一：指定线程池的线程数量（核心线程）：corePoolSize-------------------------》不能小于0

参数二：指定线程池可以支持的最大线程数量：maximumPoolSize-----------------》最大数量>=核心数量

参数三：指定临时线程的最大存活时间：keepAliveTime--------------------------------》不能小于0

参数四：指定存活时间的单位（秒、分、时、天）：unit--------------------------------》时间单位

参数五：指定任务队列：workQueue----------------------------------------------------------》不能为null

参数六：指定用哪个线程工厂创建线程：threadFactory---------------------------------》不能为null

参数七：指定线程忙、任务慢的时候，新任务来了怎么办：handler-----------------》不能为null



## 线程池常见面试题

### 临时线程什么时候创建？

- 新任务提交时发现核心线程都在忙，而且任务队列也排满了！并且还可以创建临时线程，此时才会创建临时线程

### 什么时候会开始拒绝任务？

- 核心线程和临时线程都在忙，而且任务队列也满了！！新任务过来的时候才会开始任务拒绝



## 线程池处理Runnable任务

ThreadPoolExecutor创建线程池对象实例

```java
ExecutorService pools = new ThreadPoolExecutor(3,//指定线程池的线程数量（核心线程）
                                               5,//指定线程池可以支持的最大线程数量
                                               8,//指定临时线程的最大存活时间
                                               TimeUnit.SECONDS,//指定存活时间的单位
                                               new ArrayBlockingQueue<>(6),//指定任务队列
                                               Executor.defaultThreadFactory(),//指定用哪个线程工厂创建线程
                                               new ThreadPoolExecutor.AbortPolicy());//指定线程忙、任务慢的时候，新任务来了怎么办
```

ExecutorService的常用方法

| 方法名称                               | 说明                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| void execute(Runnable command)         | 执行任务/命令，没有返回值，一般用来执行Runnable任务          |
| Future< T > submit(Callable< T > task) | 执行任务，返回未来任务对象获取线程结果，一般拿来执行 Callable 任务 |
| void shutdown()                        | 等待任务执行完毕后关闭线程池                                 |
| List < Runnable > shutdownNow()        | 立刻关闭，停止正在执行的任务，并返回队列中未执行的任务       |

