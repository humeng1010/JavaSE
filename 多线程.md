# 多线程(重要)

## 多线程

多线程是什么？

- 多线程是指从硬件上实现多条执行流程的技术

多线程用在哪？有什么好处

- 购票系统
- 百度网盘的下载
- 消息通信，淘宝，京东...



## 多线程的创建

### 方式一：继承Thread类

1. 定义一个子类MyThread继承线程类java.lang.Thread，重写run()方法
2. 创建MyThread类对象
3. 调用线程对象的start()方法启动线程

```java
package com.demo1;

/**
 * 掌握多线程的创建方式一：继承Thread类
 */
public class Demo1 {
    public static void main(String[] args) {
        //1、new一个新线程对象，代表线程
        Thread t = new MyThread();
        //2、调用start方法执行线程中的run方法
        t.start();//实现了多线程

        //写一个主线程
        for (int i = 0; i < 5; i++) {
            System.out.println("主线程执行输出" + i);
        }

    }
}

/**
 * 定义一个线程类继承Thread类
 */
class MyThread extends Thread{
    /**
     * 重写run方法，里面是定义线程以后要干啥
     */
    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println("子线程执行输出" + i);
        }
    }
}

```



#### 优缺点：

- 优点：编码简单
- 缺点：线程类已经继承Thread，无法继承其他类，不利于扩展

#### 疑问：

为什么不是调用run方法启动多线程，而是调用start方法呢？

- 如果直接调用run方法会当成普通方法执行，此时相当于还是单线程执行

#### 注意点：

**不要**把**主线程**的任务放到**子线程**任务之前，否则主线程一直是先跑完的，相当于是一个单线程的效果了。



### 方式二：实现Runnable接口

1. 定义一个线程任务类MyRunnable实现Runnable接口，重写run()方法
2. 创建MyRunnable任务对象
3. 把MyRunnable任务对象交给Thread处理
4. 调用线程对象的start()方法启动线程



```java
package com.demo1;

public class Demo2 {
    public static void main(String[] args) {
        //创建一个任务对象
        Runnable target = new MyRunnable();
        //把任务对象交给Thread对象处理
        Thread t = new Thread(target);
        //启动线程
        t.start();

        //定义主线程（在main中）
        for (int i = 0; i < 10; i++) {
            System.out.println("主线程执行输出" + i);
        }


    }
}

/**
 * 定义一个线程任务类，实现Runnable接口
 */
class MyRunnable implements Runnable{

    /**
     * 实现run方法
     */
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println("子线程执行输出" + i);
        }
    }
}

```



#### 优缺点：

- 优点：线程任务只是实现接口，可以继续继承和实现接口，扩展性强
- 缺点：编程多一层对象包装，如果线程有执行结构，是不可以直接返回的



#### 实现Runnable接口（匿名内部类形式）

```java
package com.demo1;

public class Demo2 {
    public static void main(String[] args) {
        

        //匿名内部类形式
        Runnable target = new Runnable(){
            @Override
            public void run() {
                for (int i = 0; i < 10; i++) {
                    System.out.println("子线程1执行输出" + i);
                }
            }
        };
        Thread thread = new Thread(target);
        thread.start();
        //简化
        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 10; i++) {
                    System.out.println("子线程2执行输出" + i);
                }
            }
        }).start();
        //简化
        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                System.out.println("子线程3执行输出" + i);
            }
        }).start();

        //定义主线程（在main中）
        for (int i = 0; i < 10; i++) {
            System.out.println("主线程执行输出" + i);
        }


    }
}



```



### 方式三：JDK5.0新增：实现Callable接口

- 前两种线程创建的方式都存在一个问题：
  - 他们重写的run方法不能返回结果
  - 不适合需要返回线程执行结果的业务场景
- 于是JDK5.0提供了Callable和FutureTask，可以解决这个问题



1. 得到任务对象
   - 定义类实现Callable接口，重写call方法，封装要做的事情
   - 用FutureTask把Callable对象封装成线程任务对象
2. 把线程任务对象交给Thread处理
3. 调用Thread的start方法启动线程，执行任务
4. 线程执行完毕后，通过FutureTask的get方法区获取任务执行的结果



```java
package com.demo1;

import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;

public class Demo3 {
    public static void main(String[] args) {
        //创建任务对象
        Callable<String> call = new MyCallable(100);
        //把Callable任务对象交给FutureTask对象
        //FutureTask对象的作用1：是Runnable的对象（实现了Runnable接口），可以交给Thread了
        //FutureTask对象的作用2：可以在线程执行完毕后通过调用其get方法得到线程执行完毕的结果
        FutureTask<String> task = new FutureTask<>(call);
        //交给线程处理
        Thread thread = new Thread(task);
        //启动线程
        thread.start();
        //获取结果（主线程）
        try {
            //如果task任务没有执行完，这里的代码会等待，直到线程跑完才取出结果
            String rs1 = task.get();
            System.out.println("第一个结果："+rs1);
        }  catch (Exception e) {
            e.printStackTrace();
        }

        Callable<String> call2 = new MyCallable(200);
        FutureTask<String> task2 = new FutureTask<>(call2);
        Thread thread2 = new Thread(task2);
        thread2.start();
        try {
            String rs2 = task2.get();
            System.out.println("第二个结果："+rs2);
        } catch (Exception e) {
            e.printStackTrace();
        }


    }
}

/**
 * 定义一个任务类，实现Callable接口，应该声明线程任务执行完毕后的结果数据类型
 */
class MyCallable implements Callable<String>{
    //计算1到n的和
    private int n;

    public MyCallable(int n) {
        this.n = n;
    }

    /**
     * 重写call方法
     * @return
     * @throws Exception
     */
    @Override
    public String call() throws Exception {
        int sum = 0;
        for (int i = 0; i <= n; i++) {
            sum += i;
        }
        return "子线程执行的结果为：" + sum;
    }
}
```



#### 优缺点：

- 优点：线程任务类只是实现接口，可以继续继承和实现接口，扩展性强
- 优点：可以在线程执行完毕后通过FutureTask的get方法获取执行结果，如果没有执行完毕（一定要调用Thread的start方法，才能执行！！）会等待执行完毕后，获取结果）
- 缺点：编码复杂一些



### 总结

| 方式             | 优点                                                         | 缺点                                                       |
| ---------------- | ------------------------------------------------------------ | ---------------------------------------------------------- |
| 继承Thread类     | 编码简单，可以直接使用Thread类中的start方法启动线程          | 扩展性较差，不能在继续继承其他的类，不能返回线程执行的结果 |
| 实现Runnable接口 | 扩展性强，实现该接口的同时还可以继承其他的类                 | 编程相对复杂，不能返回线程执行的结果                       |
| 实现Callable接口 | 扩展性强，实现该接口的同时还可以继承其他的类，可以得到线程执行的结果 | 编程相对复杂                                               |



## Thread的常用方法





